## 1. 영속성 컨텍스트

---

### [영속성 컨텍스트란?]

- 엔티티를 영구 저장하는 환경으로 논리적인 개념
- 엔티티 매니저를 통해 접근할 수 있다.
- 내부적으로 캐시 (1차 캐시)를 관리한다.



### [엔티티의 생명 주기]

![엔티티 생명주기](https://github.com/aycish/jpa-study/tree/main/src/main/resources/life_cycle_of_entity.png)

- 비영속 (new / transient)
    - 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
    - 멤버 객체를 생성한 뒤, 아직 persist등을 통해 영속성을 부여하지 않은 상태
    - JPA와 전혀 관계없는 상태
- 영속 (managed)
    - 영속성 컨텍스트에 관리되는 상태
    - 객체를 생성한 뒤, 엔티티 매니저에 객체를 저장한 상태
    - em.persist(member) 수행
    - 아직 DB에는 해당 내용이 저장되어 있지 않으며, 트랜잭션이 커밋되는 시점에 쿼리가 발행된다.
- 준 영속상태 (detached)
    - em.detach(member)
    - 영속성 컨텍스트에서 삭제한 상태
- 삭제 (removed)
    - em.remove(member)
    - 실제 DB에서 삭제하는것을 요구한 상태

## 2. 영속성 컨텍스트의 이점

---

### [요약]

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

### [영속성 컨텍스트의 이점 1. 1차캐시]

- 조회시에 JPA가 DB에 바로 접근하는것이 아닌, 캐시에 있는 값을 조회해온다.
- 1차 캐시에 존재하지 않으면, DB를 조회한 뒤, 결과를 1차 캐시에 저장하고, 반환하여 사용자가 사용할 수 있다.
- entityManager는 트랜잭션 시작시에 생성되서 종료시에 삭제된다. 즉, 1차 캐시의 라이프사이클이 그렇게 길지 않으며, 이점이 그렇게 크진 않다.

### [영속성 컨테긋트의 이점 2. 동일성 보장]

- 1차 캐시로 반복 가능한 읽기 등급(REPEATABLE READ)의 트랜잭션 격리 수준을 데이터베이스가 아닌 어플리케이션 차원에서 제공
- 간단하게 얘기하면, 같은 트랜잭션 안에서 JPA가 서로 객체 비교(?)를 통해 같은 데이터라고 인식할 수 있게된다.

### [영속성 컨테슥트의 이점 3. 트랜잭션을 지원하는 쓰기 지연]

- em.persist(member) 수행시, INSERT SQL을 데이터베이스에 바로 발행하지 않고, 쓰기 지연 SQL 저장소에 INSERT 쿼리를 쌓아둔다.
- 또한, 1차 캐시에 엔티티를 등록해둔다.
- 커밋하는 순간 db에 쿼리를 발행한다.
    - hibernate.jdbc.batch_size 라는 옵션으로 쿼리를 모았다가 발행하는 옵션이 존재하므로 조절할 수 있다.


### [영속성 컨테이너의 이점 4. 변경 감지]

- 엔티티 매니저에서 원하는 객체를 꺼내온 뒤, 수정한 다음 따로 persist를 호출하지 않아도 알아서 update 쿼리가 발행된다.
- 트랜잭션 커밋시 flush() 호출한다. 이때 엔티티 (1차 캐시)와 스냅샷을 비교한다. 변경점이 있다면, 쓰기 지연 SQL 저장소에 업데이트 쿼리를 쌓아둔 다음, 이후 처리된다.
- **JPA의 목적은 엔티티를 자바의 컬렉션처럼 사용하기 위함을 상기하자**

### [영속성 컨테이너의 이점 5. 지연 로딩]

- 엔티티의 삭제하는 경우를 생각해보자
- 변경을 감지하는 메커니즘과 동일하게 동작하지만, 대신 delete 쿼리가 발행된다.
- 마찬가지로 commit 시점에서 쿼리가 발행된다.

## 3. Flush

---

### [요약]

- 영속성 컨텍스트를 비우지 않음
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화한다.
- 트랜잭션이라는 작업 단위에 맞춰, 커밋 시점에만 실행되며, 정합성을 보장해준다.

### [플러시란]

- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것
- 영속성 컨텍스트의 내용은 비우지 않는다.
- 변경이 감지되고, 수정된 엔티티에 대한 쓰기 지연 SQL에 관련 쿼리가 저장된다.
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.
    - INSERT, UPDATE, DELETE 쿼리등이 저장된다.

### [영속성 컨텍스트를 플러시하는 방법]

- em.flush()
    - 직접 호출
- tx.commit()
    - 플러시 자동 호출
- JPQL 쿼리 실행
    - 플러시 자동 호출
    - persist() 호출한 뒤, 바로 조회하는 경우, DB에 내용이 없으므로 쿼리 발행 시 flush를 모두 발행하여 DB와 영속성 컨텍스트를 동기화한 뒤, 쿼리를 실행한다.

### [플러시 모드 옵션]

- em.setFlushMode(FlushModeType.COMMIT)
- FlushModeType.AUTO
    - 커밋이나 쿼리를 실행할 때 플러시 (기본값)
- FLushModeType.COMMIT
    - 커밋할 때만 플러시하기
    - 수정하려는 엔티티 객체와 관계없는 데이터를 가져오려고 할때, 굳이 업데이트가 필요하지 않으므로 설정할 수 있음

## 4. 준영속 상태

---

### [준영속 상태란]

- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된것 (detached)
- 영속성 컨텍스트가 제공하는 기능을 사용하지 못한다.

### [준영속 상태로 만드는 방법]

- em.detach(member)
    - 특정 엔티티만 준영속 상태로 전환
- em.clear()
    - 영속성 컨텍스트를 완전히 초기화
    - 캐시를 모두 지우기 때문에, 메서드 호출 이후 find() 수행한다면 다시 쿼리를 발행한다.
- em.close()
    - 영속성 컨텍스트를 종료